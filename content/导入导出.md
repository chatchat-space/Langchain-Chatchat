---
author: 技术平台部
---
# 导入导出

## Excel数据导入组件

> duceap excel数据导入组件，支持定义excel导入模板，并接收前台上传的excel文件进行模板验证通过后将excel数据导入至缓存表，针对缓存表做增删改查操作，同时可以定义导入数据处理类处理正确的数据导入到业务表，并记录导入日志。

> 导入组件目前只支持MySQL和Oracle数据库。

>使用导入组件前，需要配置默认的redis数据源，保证Spring的redis操作模板StringRedisTemplate可以正常使用。


### 1. POM文件
```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.dragonsoft</groupId>
    <artifactId>demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>demo</name>

    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencyManagement>
        <dependencies>
            <!-- 导入duceap 2.2.0 POM定义-->
            <dependency>
                <groupId>com.dragonsoft</groupId>
                <artifactId>duceap-parent</artifactId>
                <version>2.2.0-SNAPSHOT</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>

        <!--核心服务包-->
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter</artifactId>
        </dependency>
        <!--web开发基础包-->
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter-web</artifactId>
        </dependency>
        <!--redis缓存-->
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter-cache-redis</artifactId>
        </dependency>
        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter-excelimport</artifactId>
        </dependency>
        <!--mybatis-->
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter-mybatis</artifactId>
        </dependency>
        <!--flyway-->
        <dependency>
            <groupId>com.dragonsoft</groupId>
            <artifactId>duceap-boot-starter-flyway</artifactId>
        </dependency>
        <!--根据数据库类型选择相应的依赖-->
        <dependency>
            <groupId>com.oracle</groupId>
            <artifactId>ojdbc6</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
    <!--指定仓库地址-->
    <repositories>
        <repository>
            <id>public-repository</id>
            <name>Team Nexus Release Repository</name>
            <url>http://192.168.6.13:8081/nexus/content/groups/public</url>
        </repository>
        <repository>
            <id>duceap-releases</id>
            <name>Team Nexus Release Repository</name>
            <url>http://192.168.6.13:8081/nexus/content/groups/Dragon</url>
            <releases><enabled>true</enabled><updatePolicy>always</updatePolicy></releases>
            <snapshots><enabled>true</enabled><updatePolicy>always</updatePolicy></snapshots>
        </repository>
    </repositories>

    <!-- 设定插件仓库 如有Nexus私服, 取消注释并指向正确的服务器地址.-->
    <pluginRepositories>
        <pluginRepository>
            <id>nexus</id>
            <name>Team Nexus Repository</name>
            <url>http://192.168.6.13:8081/nexus/content/groups/public</url>
            <releases><enabled>true</enabled><updatePolicy>always</updatePolicy></releases>
            <snapshots><enabled>true</enabled><updatePolicy>always</updatePolicy></snapshots>
        </pluginRepository>
    </pluginRepositories>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>


```

### 2. 基础配置说明

```
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/duceap_20?characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

#定义端口
server.port=8888
#关闭license许可认证
duceap.license.enabled=false

#配置redis默认数据源
spring.redis.database=0
spring.redis.host=192.168.10.2
spring.redis.port=6379
spring.redis.password=
spring.redis.jedis.pool.max-active=8
spring.redis.jedis.pool.max-wait=-1
spring.redis.jedis.pool.max-idle=8
spring.redis.jedis.pool.min-idle=0
spring.redis.timeout=60000

#配置可上传文件大小，springboot默认文件上传大小只有1M
spring.servlet.multipart.max-file-size=1024MB
spring.servlet.multipart.max-request-size=1024MB

#flayway自动执行[true：开启（默认）、false:关闭]
duceap.flyway.enabled=true
#默认根据驱动名进行自动匹配，同时可以显示通过flyway.dbtype指定数据库类型
#duceap.flyway.dbtype=mysql
#当没有配置flyway脚本扫描器类，默认加载此目录下flyway脚本,sql/oracle可不配置，只配置模块名即可。多个逗号隔开
duceap.flyway.locations=classpath:/sql/mysql/
#同时可指定加载classpath、filesystem下的flyway脚本，如下：
#duceap.flyway.locations=classpath:/sql/oracle/DUCEAP/
###############其他默认配置######################
#duceap.flyway.placeholderPrefix=#{
#duceap.flyway.placeholderSuffix=}
#duceap.flyway.outOfOrder=true
#duceap.flyway.initOnMigrate=true
#duceap.flyway.initVersion=0.5.0
#duceap.flyway.ignoreFailedFutureMigration=false
#数据表空间
#duceap.flyway.placeholders.TABLESPACE_DATA=USERS
#索引表空间
#duceap.flyway.placeholders.TABLESPACE_INDEX=USERS
#大字段表空间
#duceap.flyway.placeholders.TABLESPACE_LOB=USERS

#driver可不配置，根据url自动匹配
#spring.datasource.driver-class-name=com.mysql.jdbc.Driver
#连接池配置(默认数据库连接池hikari)
## 最小空闲连接数量，默认是10
#spring.datasource.hikari.minimum-idle=10
## 连接池最大连接数，默认是10
#spring.datasource.hikari.maximum-pool-size=10
#druid连接池配置
#注意：项目中如果有依赖阿里的druid包或者引入了审计组件duceap-boot-starter-auditlog 则是druid连接池
# 初始化大小
#spring.datasource.druid.initialSize=5
#最小连接数
#spring.datasource.druid.minIdle=5
#最大连接数
#spring.datasource.druid.maxActive=10
#打印sql日志
#spring.jpa.show-sql=true
#配置hibernate方言
#spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.OracleDialect
#定义应用名
#spring.application.name = test
#指定上下文
#server.servlet.context-path=/test




```

### 3.使用说明

```java
import java.util.Date;

import javax.validation.constraints.NotEmpty;

import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.annotation.format.DateTimeFormat;
import com.dragonsoft.duceap.base.entity.metadata.MetaDataType;
import com.dragonsoft.duceap.commons.util.excel.annotation.CodeFormat;
import com.dragonsoft.duceap.commons.util.excel.annotation.EnumFormat;
import com.dragonsoft.duceap.commons.util.validate.annotations.Car;
import com.dragonsoft.duceap.commons.util.validate.annotations.Code;
import com.dragonsoft.duceap.commons.util.validate.annotations.DateTimeString;
import com.dragonsoft.duceap.commons.util.validate.annotations.Email;
import com.dragonsoft.duceap.commons.util.validate.annotations.Enum;
import com.dragonsoft.duceap.commons.util.validate.annotations.GBKSize;
import com.dragonsoft.duceap.commons.util.validate.annotations.IdCard;
import com.dragonsoft.duceap.commons.util.validate.annotations.MobilePhone;
import com.dragonsoft.duceap.commons.util.validate.annotations.Number;
import com.dragonsoft.duceap.commons.util.validate.annotations.QQ;
import com.dragonsoft.duceap.commons.util.validate.annotations.Wechat;
import com.dragonsoft.duceap.commons.util.validate.enums.NumberTypeEnum;
import com.dragonsoft.duceap.excelimport.annotations.ExcelEntity;
import com.dragonsoft.duceap.excelimport.annotations.ExcelImportConfig;
import com.dragonsoft.duceap.excelimport.annotations.ExcelImportProperty;
import com.dragonsoft.duceap.excelimport.entity.PersonInfo;
import com.dragonsoft.duceap.excelimport.handlers.PersonImportHandler;

import lombok.Data;

@SuppressWarnings("serial")
@ExcelEntity(id = "person", name = "人员数据导入", templatePath = "template/person-template.xlsx")
@ExcelImportConfig(entity = PersonInfo.class, handler = PersonImportHandler.class, primaryKey = "id")
@Data
public class PersonImportVo extends ExcelImportBaseModel {

	@ExcelProperty(index = 0)
	@ExcelImportProperty(order = 1, display = "姓名")
	@NotEmpty(message = "姓名不能为空")
	@GBKSize(max = 50, message = "姓名不能超过50个字")
	private String name;

	@ExcelProperty(index = 1)
	@ExcelImportProperty(order = 2, display = "身份证号")
	@NotEmpty(message = "身份证号不能为空")
	@IdCard
	private String idcard;

	@ExcelProperty(index = 2)
	@ExcelImportProperty(order = 3, display = "出生日期", type = MetaDataType.DATE, format = "yyyy-MM-dd")
	@DateTimeFormat("yyyy-MM-dd")
	private Date birthday;

	@ExcelProperty(index = 3)
	@ExcelImportProperty(order = 4, display = "性别", length = 20, type = MetaDataType.CODE, format = "DM_SEX")
	@Code(codeId = "DM_SEX", message = "性别代码错误")
	@CodeFormat("DM_SEX")
	private String sex;

	@ExcelProperty(index = 4)
	@ExcelImportProperty(order = 5, display = "体重", length = 20, type = MetaDataType.NUMBER)
	@Number(type = NumberTypeEnum.DOUBLE, min = 2, max = 300, message = "体重必须在2~300KG之间")
	private String weight;

	@ExcelProperty(index = 5)
	@ExcelImportProperty(order = 6, display = "身高", length = 20, type = MetaDataType.NUMBER)
	@Number(type = NumberTypeEnum.LONG, min = 10, max = 300, message = "身高必须在10~300cm之间")
	private String height;

	@ExcelProperty(index = 6)
	@ExcelImportProperty(order = 7, display = "民族", length = 20, type = MetaDataType.CODE, format = "DM_NATION")
	@Code(codeId = "DM_NATION", message = "民族代码错误")
	@CodeFormat("DM_NATION")
	private String nation;

	@ExcelProperty(index = 7)
	@ExcelImportProperty(order = 8, display = "QQ")
	@GBKSize(max = 100, message = "QQ不能超过100个字")
	@QQ(split = ",", message = "QQ号码格式错误")
	private String qq;

	@ExcelProperty(index = 8)
	@ExcelImportProperty(order = 9, display = "微信")
	@GBKSize(max = 100, message = "微信不能超过100个字")
	@Wechat(split = ",", message = "微信号码格式错误")
	private String wechat;

	@ExcelProperty(index = 9)
	@ExcelImportProperty(order = 10, display = "邮箱")
	@GBKSize(max = 100, message = "邮箱不能超过100个字")
	@Email(split = ",", message = "邮箱格式错误")
	private String email;

	@ExcelProperty(index = 10)
	@ExcelImportProperty(order = 11, display = "手机号码")
	@GBKSize(max = 100, message = "手机号码不能超过100个字")
	@MobilePhone(split = ",", message = "手机号码格式错误")
	private String mobilephone;

	@ExcelProperty(index = 11)
	@ExcelImportProperty(order = 12, display = "车牌号码")
	@GBKSize(max = 100, message = "车牌号码不能超过100个字")
	@Car(split = ",", message = "车牌号码格式错误")
	private String carNum;

	@ExcelProperty(index = 12)
	@ExcelImportProperty(order = 13, display = "职业")
	@GBKSize(max = 100, message = "职业不能超过100个字")
	private String duty;

	@ExcelProperty(index = 13)
	@ExcelImportProperty(order = 14, display = "工作单位")
	@GBKSize(max = 150, message = "工作单位不能超过150个字")
	private String company;

	@ExcelProperty(index = 14)
	@ExcelImportProperty(order = 15, display = "工作时间", type = MetaDataType.DATE, format = "yyyy-MM-dd")
	@GBKSize(max = 50, message = "工作时间不能超过50个字")
	@DateTimeFormat("yyyyMMdd")
	@DateTimeString(formatStr = "yyyyMMdd", message = "工作时间格式错误")
	private String hiredate;

	@ExcelProperty(index = 15)
	@ExcelImportProperty(order = 16, display = "户籍地区划", length = 50, type = MetaDataType.CODE, format = "DM_AREA_CODE", isTree = true)
	@Code(codeId = "DM_AREA_CODE", message = "户籍地区划代码错误")
	@CodeFormat("DM_AREA_CODE")
	private String domicile;

	@ExcelProperty(index = 16)
	@ExcelImportProperty(order = 17, display = "户籍地详址")
	@GBKSize(max = 300, message = "户籍地详址不能超过300个字")
	private String domicileAddress;

	@ExcelProperty(index = 17)
	@ExcelImportProperty(order = 18, display = "现住地区划", length = 50, type = MetaDataType.CODE, format = "DM_AREA_CODE", isTree = true)
	@Code(codeId = "DM_AREA_CODE", message = "现住地区划代码错误")
	@CodeFormat("DM_AREA_CODE")
	private String currentHome;

	@ExcelProperty(index = 18)
	@ExcelImportProperty(order = 19, display = "现住地详址")
	@GBKSize(max = 300, message = "现住地详址不能超过300个字")
	private String currentHomeAddress;

	@ExcelProperty(index = 19)
	@ExcelImportProperty(order = 20, display = "宗教信仰", length = 20, type = MetaDataType.CODE, format = "DM_ZJXY")
	@Code(codeId = "DM_ZJXY", message = "宗教信仰代码错误")
	@CodeFormat("DM_ZJXY")
	private String belief;

	@ExcelProperty(index = 20)
	@ExcelImportProperty(order = 21, display = "兵役状况", length = 20, type = MetaDataType.CODE, format = "DM_BYZK")
	@Code(codeId = "DM_BYZK", message = "兵役状况代码错误")
	@CodeFormat("DM_BYZK")
	private String military;

	@ExcelProperty(index = 21)
	@ExcelImportProperty(order = 22, display = "文化程度", length = 20, type = MetaDataType.CODE, format = "DM_WHCD")
	@Code(codeId = "DM_WHCD", message = "文化程度代码错误")
	@CodeFormat("DM_WHCD")
	private String eduDegree;

	@ExcelProperty(index = 22)
	@ExcelImportProperty(order = 23, display = "毕业时间", type = MetaDataType.DATE, format = "yyyy-MM-dd")
	@GBKSize(max = 50, message = "毕业时间不能超过50个字")
	@DateTimeFormat("yyyyMMdd")
	@DateTimeString(formatStr = "yyyyMMdd", message = "毕业时间格式错误")
	private String graduateTime;

	@ExcelProperty(index = 23)
	@ExcelImportProperty(order = 24, display = "人员状态", length = 20, type = MetaDataType.ENUM, format = "PersonStateEnum")
	@Enum(enumName = "PersonStateEnum", message = "人员状态代码错误")
	@EnumFormat("PersonStateEnum")
	private String personState;

	@ExcelProperty(index = 24)
	@ExcelImportProperty(order = 25, display = "数据来源", length = 20, type = MetaDataType.ENUM, format = "PersonDatasourceEnum", multiple = true)
	@Enum(enumName = "PersonDatasourceEnum", message = "数据来源代码错误", split = ",")
	@EnumFormat("PersonDatasourceEnum")
	private String datasource;

	@ExcelProperty(index = 25)
	@ExcelImportProperty(order = 26, display = "注册时间", type = MetaDataType.DATE, format = "yyyy-MM-dd HH:mm:ss")
	@DateTimeFormat("yyyy-MM-dd HH:mm:ss")
	private Date createTime;

	@ExcelProperty(index = 26)
	@ExcelImportProperty(order = 27, display = "更新时间", length = 30, type = MetaDataType.DATE, format = "yyyy-MM-dd HH:mm:ss")
	@DateTimeFormat("yyyyMMddHHmmss")
	@DateTimeString(formatStr = "yyyyMMddHHmmss", message = "更新时间格式错误")
	private String updateTime;

}
```

####3.2.3 实体类

```java
import java.util.Date;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import lombok.Data;

@SuppressWarnings("serial")
@Data
@TableName(value = "T_PERSON")
public class PersonInfo implements java.io.Serializable {

	@TableField(value = "ID")
	@TableId(type = IdType.INPUT)
	private String id;

	@TableField(value = "NAME")
	private String name;

	@TableField(value = "IDCARD")
	private String idcard;

	@TableField(value = "BIRTHDAY")
	private Date birthday;

	@TableField(value = "SEX")
	private String sex;

	@TableField(value = "WEIGHT")
	private String weight;

	@TableField(value = "HEIGHT")
	private String height;

	@TableField(value = "NATION")
	private String nation;

	@TableField(value = "QQ")
	private String qq;

	@TableField(value = "WECHAT")
	private String wechat;

	@TableField(value = "EMAIL")
	private String email;

	@TableField(value = "MOBILEPHONE")
	private String mobilephone;

	@TableField(value = "CAR_NUM")
	private String carNum;

	@TableField(value = "DUTY")
	private String duty;

	@TableField(value = "COMPANY")
	private String company;

	@TableField(value = "HIREDATE")
	private String hiredate;

	@TableField(value = "DOMICILE")
	private String domicile;

	@TableField(value = "DOMICILE_ADDRESS")
	private String domicileAddress;

	@TableField(value = "CURRENT_HOME")
	private String currentHome;

	@TableField(value = "CURRENT_HOME_ADDRESS")
	private String currentHomeAddress;

	@TableField(value = "BELIEF")
	private String belief;

	@TableField(value = "MILITARY")
	private String military;

	@TableField(value = "EDU_DEGREE")
	private String eduDegree;

	@TableField(value = "GRADUATE_TIME")
	private String graduateTime;

	@TableField(value = "PERSON_STATE")
	private String personState;

	@TableField(value = "DATASOURCE")
	private String datasource;

	@TableField(value = "CREATE_TIME")
	private Date createTime;

	@TableField(value = "UPDATE_TIME")
	private String updateTime;

	@TableField(value = "REMARK")
	private String remark;

}
```

####3.2.4 导入处理类

- 导入处理类用于指定excel数据读取、修改、导入正式表三个过程的处理器，可以注册为Spring的Bean，也可以使用普通的类，**一般情况我们只需要实现writeHolder()即可，然后实现对应的process方法进行数据保存**即可，如果实际需求中有其他需要，可实现对应的方法去满足需求。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @description：人员信息导入处理类，一般情况只需要实现writeHolder()即可，然后实现对应的process方法进行数据保存
 */
@Component
public class PersonImportHandler implements ExcelImportHandler<PersonImportVo, PersonInfo> {

	// excel数据读取到缓存表处理类
	@Autowired
	private PersonImportReadHandle personImportReadHandle;

	// 缓存表数据修改、删除等编辑操作时的一些回调
	@Autowired
	private PersonImportEditHandler personImportEditHandler;

	// 数据从缓存表导入到正式表时的处理类
	@Autowired
	private PersonImportWriteHandler personImportWriteHandler;

	@Override
	public ExcelImportReadHandler<PersonImportVo> readHolder() {
		return personImportReadHandle;
	}

	@Override
	public ExcelImportEditHandler<PersonImportVo> editHolder() {
		return personImportEditHandler;
	}

	@Override
	public ExcelImportWriteHandler<PersonInfo> writeHolder() {
		return personImportWriteHandler;
	}

}
```

- excel数据读取到缓存表处理类，用于处理excel数据读取之前之后回调，以及读取excel数据时做自定义验证，以及一些数据处理

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.dragonsoft.duceap.commons.util.excel.handler.ValidateErrorBuilder;
import com.dragonsoft.duceap.commons.util.excel.handler.ValidateErrorBuilder.Builder;
import com.dragonsoft.duceap.excelimport.context.ExcelImportReadContext;

/**
 * 
 * @description：excel数据读取到缓存表处理类，用于处理excel数据读取之前之后回调，以及读取excel数据时做自定义验证，以及一些数据处理
 * ExcelImportReadContext：读取excel时的上下文，里面存放了当前导入方案信息，当前批次号及前端传过来的参数等信息
 */
@Component
public class PersonImportReadHandle implements ExcelImportReadHandler<PersonImportVo> {

	private Logger logger = LoggerFactory.getLogger(getClass());

	@Override
	public void beforeImport(ExcelImportReadContext context) {
		//可以通过context.getParams()获取前端传过来的参数
		logger.info("需要读取数据：" + context.getTotal() + "，参数：" + context.getParams());
		//使用此方法添加导入过程中全局变量
		context.addVariable("test", 25);
	}

	/**
	 * 处理行数据，可在数据验证前对读取的excel数据做自定义处理，此方法在修改缓存表数据时也会回调
	 */
	@Override
	public void processRow(PersonImportVo row, ExcelImportReadContext context) {
		// logger.info("处理行数据：" + row.getName());
	}

	/**
	 * 自定义验证行数据，可对读取的excel数据做自定义验证处理，此方法在修改缓存表数据时也会回调，当验证注解无法满足需求时可以使用此方法
	 */
	@Override
	public Builder validate(PersonImportVo row, ExcelImportReadContext context) {
		// logger.info("自定义验证行数据：" + row.getName());
		return ValidateErrorBuilder.builder();
	}

	@Override
	public void afterImport(ExcelImportReadContext context) {
		logger.info("读取数据完成：" + context.getTotal() + "--" + context.getVariable("test", Integer.class));
	}

}
```

- excel数据缓存表回调处理类

```java
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.alibaba.fastjson.JSON;
import com.dragonsoft.duceap.excelimport.context.ExcelImportEditContext;
import com.dragonsoft.duceap.excelimport.vo.PersonImportVo;

/**
 * @description：修改缓存表数据时的一些回调事件，可以捕获到对应操作，但是对实际代码逻辑并不会产生影响
 * ExcelImportEditContext：编辑缓存数据时的上下文，里面存放了当前导入方案信息，当前批次号及前端传过来的参数等信息
 */
@Component
public class PersonImportEditHandler implements ExcelImportEditHandler<PersonImportVo> {

	private Logger logger = LoggerFactory.getLogger(getClass());

	@Override
	public void beforeUpdate(List<PersonImportVo> newData, ExcelImportEditContext context) {
		logger.info("更新数据：" + JSON.toJSONString(newData));
		logger.info("参数：" + context.getParams());
	}

	@Override
	public void afterUpdate(List<PersonImportVo> newData, ExcelImportEditContext context) {
		logger.info("更新完数据：" + JSON.toJSONString(newData));
	}

	@Override
	public void beforeDelete(List<String> rowIndexs, ExcelImportEditContext context) {
		logger.info("删除数据：" + JSON.toJSONString(rowIndexs));
		logger.info("参数：" + context.getParams());
	}

	@Override
	public void afterDelete(List<String> rowIndexs, ExcelImportEditContext context) {
		logger.info("删除完数据：" + JSON.toJSONString(rowIndexs));
	}

	@Override
	public void beforeDeleteFile(Long uploadId, ExcelImportEditContext context) {
		logger.info("删除文件：" + uploadId);
		logger.info("参数：" + context.getParams());
	}

	@Override
	public void afterDeleteFile(Long uploadId, ExcelImportEditContext context) {
		logger.info("删除完文件数据：" + uploadId);
	}

}
```

- 数据从缓存表导入到正式表时的处理类

```java
import java.util.List;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.alibaba.fastjson.JSON;
import com.dragonsoft.duceap.excelimport.context.ExcelImportWriteContext;
import com.dragonsoft.duceap.excelimport.entity.PersonInfo;

/**
 * @description：数据导入到正式表的处理类
 * ExcelImportWriteContext：导入数据时读取excel时的上下文，里面存放了当前导入方案信息，当前批次号及前端传过来的参数等信息
 */
@Component
public class PersonImportWriteHandler implements ExcelImportWriteHandler<PersonInfo> {

	private Logger logger = LoggerFactory.getLogger(getClass());

	/**
	 * 将缓存表数据导入到正式业务表之前处理函数
	 *
	 * @param rowIndexs 选中的序号
	 * @param context   导入数据上下文
	 */
	@Override
	public void beforeProcess(List<String> rowIndexs, ExcelImportWriteContext context) {
		logger.info("导入数据：" + JSON.toJSONString(rowIndexs));
		logger.info("参数：" + context.getParams());
	}

	/**
	 * 自定义处理带导入数据单个实体类，主要用于处理字段信息
	 *
	 * @param entity  导入实体类
	 * @param context 导入数据上下文
	 */
	@Override
	public void processRow(PersonInfo entity, ExcelImportWriteContext context) {
		entity.setId(UUID.randomUUID().toString());
	}

	 /**
	   * 缓存表数据导入到正式表处理函数
     * @param batchData 批次处理数据
     * @param context   导入数据上下文
     * @return
     */
	@Override
	public boolean process(List<PersonInfo> batchData, ExcelImportWriteContext context) {
		// 批量插入数据
		logger.info("批量保存数据：" + batchData.size());
		logger.info("参数：" + context.getParams());
		return true;
	}

	 /**
	   * 将缓存表数据导入到正式业务表之后处理函数
     *
     * @param rowIndexs 选中的序号
     * @param context   导入数据上下文
     */
	@Override
	public void afterProcess(List<String> rowIndexs, ExcelImportWriteContext context) {
		logger.info("批量保存数据结束：" + JSON.toJSONString(rowIndexs));
	}

	/**
	   * 导入数据完成后返回到页面的提示信息
     *
     * @param context 导入数据上下文
     * @return
     */
	@Override
	public String getProcessedMessage(ExcelImportWriteContext context) {
		return "成功导入了数据" + context.getSuccessCount() + "条！";
	}

}
```



## ExcelUtils导入导出

ExcelUtils基于[easyExcel](https://www.yuque.com/easyexcel/doc/easyexcel) 进行了二次封装，提供了更加快捷方式读取excel转换成实体类或Map集合数据，主要扩展以下功能：
-  **数据校验：** 结合hibernate-validator实现bean的属性校验，并扩展常用校验规则，加入字典项、枚举、身份证号、日期格式等的校验，同时还加入自定义校验回调，在读取数据时完成自定义规则校验，使数据校验更加简单，具体扩展校验如下：

```
  @Code：字典项验证，指定codeId，判断数据是否在字典表中存在
  @Enum：枚举验证，指定枚举名称，判断数据是否是枚举中的选项
  @IdCard：判断数据是不是身份证号
  @DateTimeString：判断数据是否为指定日期格式的字符串
  @GBKSize：判断数据的中文长度，可指定最大长度和最小长度
  @Number：判断数据是否为数字(整型，浮点型)，可指定最大值和最小值
  @MobilePhone：判断数据是否为手机号码，支持多个按照特定分隔符分隔
  @Email：判断数据是否为邮箱，支持多个按照特定分隔符分隔
  @Car：判断数据是否为车牌号码，支持多个按照特定分隔符分隔
  @QQ：判断数据是否为QQ号码，支持多个按照特定分隔符分隔
  @Wechat：判断数据是否为微信号码，支持多个按照特定分隔符分隔
  ```
-  **数据转换：** 将excel中的数据转换成应用需要的有效数据

```
  @CodeFormat：可以反向翻译字典(即将excel中的中文数据转换成代码)，eg：男->1 女->2
  @EnumFormat：可以反向翻译枚举
  @DateTimeFormat：作用在字符串属性上，能够将时间字符串转换成固定格式的日期字符串
```
- **数据去重：** 读取数据时按照某些属性组合对数据去重

- **数据过滤：** 读取数据时自定义过滤规则，排出掉不需要处理的数据

- **异步读取：** 自定义数据处理类，批量进行数据处理，而不是得到完整的excel数据结果集，防止OOM

- **快速读取：** 快速读取excel返回索引号映射的List<Map<Integer,String>>数据

- **指定列名读取：** 将excel按照列号索引组装成指定列名的List<Map<String,String>>数据

- **指定元数据读取：** 支持指定列映射信息，定义metadata，进行代码/枚举翻译，返回处理后的List<Map<String,String>>数据

- **多版本excel导出：** 支持2003和2007版的excel导出

- **导出excel单元格合并：** 支持导出数据按照某一列进行合并，指定列数据如果连续相同则进行单元格行合并

- **导出时循环写入：** 支持导出数据时提供写入方法，循环写入数据，不需要将所有数据查询到内存后再导出

- **模板导出：** 支持通过excel模板导出数据，满足带有格式的excel导出  

### 1. 依赖POM

```
<dependency>
  <groupId>org.ehcache</groupId>
  <artifactId>ehcache</artifactId>
</dependency>
```
### 2. excel数据对应实体类

```java
import java.util.Date;

import javax.validation.constraints.NotEmpty;

import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.annotation.format.DateTimeFormat;
import com.dragonsoft.duceap.base.enums.ICodeEnum;
import com.dragonsoft.duceap.commons.util.excel.ExcelModel;
import com.dragonsoft.duceap.commons.util.excel.annotation.CodeFormat;
import com.dragonsoft.duceap.commons.util.excel.annotation.EnumFormat;
import com.dragonsoft.duceap.commons.util.validate.annotations.Car;
import com.dragonsoft.duceap.commons.util.validate.annotations.Code;
import com.dragonsoft.duceap.commons.util.validate.annotations.DateTimeString;
import com.dragonsoft.duceap.commons.util.validate.annotations.Email;
import com.dragonsoft.duceap.commons.util.validate.annotations.Enum;
import com.dragonsoft.duceap.commons.util.validate.annotations.GBKSize;
import com.dragonsoft.duceap.commons.util.validate.annotations.IdCard;
import com.dragonsoft.duceap.commons.util.validate.annotations.MobilePhone;
import com.dragonsoft.duceap.commons.util.validate.annotations.Number;
import com.dragonsoft.duceap.commons.util.validate.annotations.QQ;
import com.dragonsoft.duceap.commons.util.validate.annotations.Wechat;
import com.dragonsoft.duceap.commons.util.validate.enums.NumberTypeEnum;

import lombok.Data;

/**
 * @description：excel导入配置类，必须继承com.dragonsoft.duceap.commons.util.excel.ExcelModel
 */
@Data
public class PersonImportVo extends ExcelModel {

    @ExcelProperty(index = 0)
    @NotEmpty(message = "姓名不能为空")
    @GBKSize(max = 50, message = "姓名不能超过50个字")
    private String name;

    @ExcelProperty(index = 1)
    @NotEmpty(message = "身份证号不能为空")
    @IdCard
    private String idcard;

    @ExcelProperty(index = 2)
    @DateTimeFormat("yyyy-MM-dd")
    private Date birthday;

    @ExcelProperty(index = 3)
    @Code(codeId = "DM_SEX", message = "性别代码错误")
    @CodeFormat("DM_SEX")
    private String sex;

    @ExcelProperty(index = 4)
    @Number(type = NumberTypeEnum.DOUBLE, min = 2, max = 300, message = "体重必须在2~300KG之间")
    private String weight;

    @ExcelProperty(index = 5)
    @Number(type = NumberTypeEnum.LONG, min = 10, max = 300, message = "身高必须在10~300cm之间")
    private String height;

    @ExcelProperty(index = 6)
    @GBKSize(max = 100, message = "QQ不能超过100个字")
    @QQ(split = ",", message = "QQ号码格式错误")
    private String qq;

    @ExcelProperty(index = 7)
    @GBKSize(max = 100, message = "微信不能超过100个字")
    @Wechat(split = ",", message = "微信号码格式错误")
    private String wechat;

    @ExcelProperty(index = 8)
    @GBKSize(max = 100, message = "邮箱不能超过100个字")
    @Email(split = ",", message = "邮箱格式错误")
    private String email;

    @ExcelProperty(index = 9)
    @GBKSize(max = 100, message = "手机号码不能超过100个字")
    @MobilePhone(split = ",", message = "手机号码格式错误")
    private String mobilephone;

    @ExcelProperty(index = 10)
    @GBKSize(max = 100, message = "车牌号码不能超过100个字")
    @Car(split = ",", message = "车牌号码格式错误")
    private String carNum;

    //人员状态使用枚举：public enum PersonStateEnum implements ICodeEnum {NORMAL("1","正常"),cancel("0","注销");}
    @ExcelProperty(index = 11)
    @Enum(enumName = "PersonStateEnum", message = "人员状态代码错误")
    @EnumFormat("PersonStateEnum")
    private String personState;

    @ExcelProperty(index = 12)
    @DateTimeFormat("yyyyMMddHHmmss")
    @DateTimeString(formatStr = "yyyyMMddHHmmss", message = "更新时间格式错误")
    private String createTime;

}
```

- example1：读取excel进行数据验证返回实体类集合
```java
InputStream excel = ExcelUtils.readInputStream(new File("F:\\person-test.xlsx"));
List<PersonImportVo> data = ExcelUtils.readWithModel(excel, PersonImportVo.class);

/**每行数据验证后错误数据会存放在invalidMsg属性中，示例数据如下：
{
    "qq": "QQ号码格式错误",
    "mobilephone": "手机号码格式错误",
    "sex": "性别代码错误",
    "wechat": "微信号码格式错误",
    "email": "邮箱格式错误",
    "height": "身高必须在10~300cm之间"
}
*/
```

- example2：读取excel进行数据验证返回实体类集合，并指定处理器，对数据进行过滤、排重、自定义验证等
```java
InputStream excel = ExcelUtils.readInputStream(new File("F:\\person-test.xlsx"));
//也可使用ExcelUtils.readWithModel(excel, PersonImportVo.class, new ExcelHandler<PersonImportVo>() {});
List<PersonImportVo> data = ExcelUtils.readWithModel(excel, new ExcelHandler<PersonImportVo>() {

    @Override
    public Integer getBeginRowIndex() {
        //从第2行还是读取数据
        return 2;
    }

    @Override
    public String[] getUniqueProperty() {
        //按照身份证号进行去重
        return new String[] {"idcard"};
    }

    @Override
    public Boolean filter(PersonImportVo row) {
        //过滤数据，只需要人员状态是正常的数据
        if("1".equals(row.getPersonState())) {
            return true;
        }
        return false;
    }

    @Override
    public Builder validate(PersonImportVo row) {
        //自定义校验，性别为女的设置为验证失败
        Builder builder = ValidateErrorBuilder.builder();
        if("女".equals(row.getSex())) {
            builder.put("sex", "人员性别不允许为女");
        }
        return builder;
    }

    @Override
    public void beforeReadSheet(int sheetNo, Map<Integer, String> headMap, int total) {
        System.out.println("读取excel数据之前，数据总数："+total);
    }

    @Override
    public void afterReadSheet(int sheetNo) {
        System.out.println("读取excel数据完成");
    }

});
```

- example3：读取excel进行数据验证返回实体类集合，并指定数据处理器，读取到一定数量数据后自定义处理数据，防止OOM

```java
InputStream excel = ExcelUtils.readInputStream(new File("F:\\person-test.xlsx"));
//也可使用ExcelUtils.readWithModel(excel, PersonImportVo.class, new ExcelBatchHandler<PersonImportVo>() {});
ExcelUtils.readWithModel(excel, new ExcelBatchHandler<PersonImportVo>() {

    @Override
    public Integer getBatchSize() {
        //每次处理1000条数据
        return 1000;
    }

    @Override
    public void process(List<PersonImportVo> batchData) {
        //获取到要处理的数据进行处理
        System.out.println(batchData.size());
    }

    @Override
    public Integer getBeginRowIndex() {
        //从第2行还是读取数据
        return 2;
    }

    @Override
    public String[] getUniqueProperty() {
        //按照身份证号进行去重
        return new String[] {"idcard"};
    }

    @Override
    public Boolean filter(PersonImportVo row) {
        //过滤数据，只需要人员状态是正常的数据
        if("1".equals(row.getPersonState())) {
            return true;
        }
        return false;
    }

    @Override
    public Builder validate(PersonImportVo row) {
        //自定义校验，性别为女的设置为验证失败
        Builder builder = ValidateErrorBuilder.builder();
        if("女".equals(row.getSex())) {
            builder.put("sex", "人员性别不允许为女");
        }
        return builder;
    }

    @Override
    public void beforeReadSheet(int sheetNo, Map<Integer, String> headMap, int total) {
        System.out.println("读取excel数据之前，数据总数："+total);
    }

    @Override
    public void afterReadSheet(int sheetNo) {
        System.out.println("读取excel数据完成");
    }

});
```

- example5：对excel列号进行列映射，返回映射属性的数据

- example5：对excel列号进行列映射，返回映射属性的数据

```java
InputStream excel = ExcelUtils.readInputStream(new File("F:\\person-test.xlsx"));

//指定列映射，数组下标与excel列序号对应
String[] columnMappers = new String[] {"name","idcard"};
//普通读取
List<Map<String, String>> data = ExcelUtils.readWithoutModel(excel,columnMappers);
//指定处理类
List<Map<String, String>> data2 = ExcelUtils.readWithoutModel(excel,columnMappers,new ExcelHandler<Map<String,String>>(){});
//指定批量处理数据类，不返回结果集，对结果集进行循环批量处理
ExcelUtils.readWithoutModel(excel,columnMappers,new ExcelBatchHandler<Map<String,String>>(){
    @Override
    public void process(List<Map<String, String>> batchData) {
        
    }
});
/**示例数据
[
  {
    "name": "顾强强",
    "idcard": "44050719600409689X",
    "_row_index": "1"//行号
  }
]
*/
```

- example6：指定元数据读取

```java
InputStream excel = ExcelUtils.readInputStream(new File("F:\\person-test.xlsx"));
		
//指定excel元数据，即对excel数据进行列名映射，代码、枚举、日期翻译等处理
List<ExcelMetaData> columns = new ArrayList<ExcelMetaData>() {{
    //指定第一列为姓名字段
    add(ExcelMetaData.newMetaData(0, "name"));
    //指定第四列为性别字段，并且使用"DM_SEX"字典将中文数据转换成代码值
    add(ExcelMetaData.newCodeMetaData(3, "sex", "DM_SEX"));
    //指定第十二列为人员状态字段，并且使用"PersonStateEnum"枚举将中文数据转换成枚举值
    add(ExcelMetaData.newEnumMetaData(11, "personState", "PersonStateEnum"));
    //指定第十三列为创建时间字段，并且将数据转换成yyyyMMddHHmmss格式的字符串
    add(ExcelMetaData.newDateMetaData(12, "createTime", "yyyyMMddHHmmss"));
}};

//普通读取
List<Map<String,String>> data = ExcelUtils.readWithoutModel(excel, columns);
//指定处理类
List<Map<String, String>> data = ExcelUtils.readWithoutModel(excel,columns,new ExcelHandler<Map<String,String>>(){});
//指定批量处理数据类，不返回结果集，对结果集进行循环批量处理
ExcelUtils.readWithoutModel(excel,columns,new ExcelBatchHandler<Map<String,String>>(){
    @Override
    public void process(List<Map<String, String>> batchData) {
        
    }
});
/**示例数据
[
  {
    "name": "刘妍梅",
    "sex": "2",
    "personState": "0",
    "createTime": "20200401020103",
    "_row_index": "3"   //行号
  }
]
*/
```

- example7：导出excel2003

```java
List<Map<String, Object>> data = new ArrayList<Map<String, Object>>() {
    {

        Map<String, Object> map1 = new HashMap<String, Object>();
        map1.put("name", "张三");
        map1.put("sex", "1");
        map1.put("createTime", "20200701122526");
        add(map1);

        Map<String, Object> map2 = new HashMap<String, Object>();
        map2.put("name", "李四");
        map2.put("sex", "1");
        map2.put("createTime", "20200701122528");
        add(map2);

        Map<String, Object> map3 = new HashMap<String, Object>();
        map3.put("name", "王五");
        map3.put("sex", "2");
        map3.put("createTime", "20200701122529");
        add(map3);
    }
};

// 指定excel元数据，即数据进行列名映射，代码、枚举、日期翻译等处理
List<MetaData> columns = new ArrayList<MetaData>() {
    {
        add(new MetaData(MetaDataType.CHAR, "name", "姓名", ""));
        add(MetaData.newCodeMetaData("sex", "性别","DM_SEX"));
        add(MetaData.newDateMetaData("createTime","创建时间","yyyy-MM-dd HH:mm:ss"));
    }
};

FileOutputStream out = new FileOutputStream(new File("F:\\person-out.xls"));
//普通导出
ExcelUtils.exportExcel2003ByMetaField("人员列表数据", data, columns, out);
/**excel导出结果
姓名	性别	创建时间
张三	男	2020-07-01 12:25:26
李四	男	2020-07-01 12:25:28
王五	女	2020-07-01 12:25:29
*/
```

- example8：导出excel2003并合并单元格

```java
//性别列进行合并
ExcelUtils.exportExcel2003ByMetaField("人员列表数据", data, columns, out, new String[] {"sex"});
/**excel导出结果
姓名	性别	创建时间
张三	男	2020-07-01 12:25:26
李四		2020-07-01 12:25:28
王五	女	2020-07-01 12:25:29
*/
```

- example9：导出excel2007

```java
//普通导出
ExcelUtils.exportExcelByMetaField("人员列表数据", data, columns, out);
//按列合并导出
ExcelUtils.exportExcelByMetaField("人员列表数据", data, columns, out, new String[] {"sex"});
```

- example10：导出excel2007并实现不指定结果集，循环写入数据

```java
// 指定excel元数据，即对excel数据进行列名映射，代码、枚举、日期翻译等处理
List<MetaData> columns = new ArrayList<MetaData>() {
    {
        add(new MetaData(MetaDataType.CHAR, "name", "姓名", ""));
        add(MetaData.newCodeMetaData("sex", "性别","DM_SEX"));
        add(MetaData.newDateMetaData("createTime","创建时间","yyyy-MM-dd HH:mm:ss"));
    }
};

FileOutputStream out = new FileOutputStream(new File("F:\\person-out.xlsx"));
//循环写入导出数据，实际应用中可以在applyData分批次获取数据写入，防止一次性把数据全部加载到内存导致OOM
ExcelUtils.exportExcelByMetaField("人员列表数据", new ExcelWriteHandler<Map<String, Object>>() {
    @Override
    public void applyData() {
        //分批次获取数据
        PersistentFactory.getJdbcDao().queryForProcess("select * from t_person where is_deleted=?", new String[] {"0"}, new ProcessCallBack() {
            @Override
            public int getBatchSize() {
                return 1000;
            }
            @Override
            public boolean process(List<Map<String, Object>> list, long currentRowIndex) {
                //写入数据
                write(list);
                return false;
            }
        });
    }
}, columns, out);

//导出时也可指定列进行单元格合并
ExcelUtils.exportExcelByMetaField("人员列表数据", new ExcelWriteHandler<Map<String, Object>>() {
    @Override
    public void applyData() {
        //分批次获取数据
        PersistentFactory.getJdbcDao().queryForProcess("select * from t_person where is_deleted=?", new String[] {"0"}, new ProcessCallBack() {
            @Override
            public int getBatchSize() {
                return 1000;
            }
            @Override
            public boolean process(List<Map<String, Object>> list, long currentRowIndex) {
                //写入数据
                write(list);
                return false;
            }
        });
    }
    //按照性别列进行合并
}, columns, out,new String[]{"sex"});

```


- example11：使用模板导出数据，支持对象嵌套

excel示例模板如下：

|A |B |C |D |E |
|----|----|----|----|----|
|姓名|{name}| | | |
|年龄|{age}| | | |
|毕业学校|毕业时间| |工作单位|入职时间|
|{education.name}|{education.time}| |{wordks.name}|{wordks.time}|

导出示例代码如下：

```java
Map<String, Object> user = new HashMap<String, Object>();
user.put("name", "张三");
user.put("age", 25);

List<Map<String, Object>> education = new ArrayList<Map<String, Object>>();
Map<String, Object> primary = new HashMap<String, Object>();
primary.put("name", "实验小学");
primary.put("time", "2005-07-01");
education.add(primary);

Map<String, Object> middle = new HashMap<String, Object>();
middle.put("name", "实验中学");
middle.put("time", "2008-07-01");
education.add(middle);

Map<String, Object> high = new HashMap<String, Object>();
high.put("name", "实验高中");
high.put("time", "2011-07-01");
education.add(high);

Map<String, Object> university = new HashMap<String, Object>();
university.put("name", "北京大学");
university.put("time", "2015-07-01");
education.add(university);
user.put("education", education);

List<Map<String, Object>> wordks = new ArrayList<Map<String, Object>>();

Map<String, Object> work1 = new HashMap<String, Object>();
work1.put("name", "华为技术有限公司");
work1.put("time", "2015-07-01");
wordks.add(work1);

Map<String, Object> work2 = new HashMap<String, Object>();
work2.put("name", "厦门巨龙");
work2.put("time", "2019-07-01");
wordks.add(work2);
user.put("wordks", wordks);

InputStream template = ExcelUtils.readInputStream(new File("F:\\person-template.xlsx"));
FileOutputStream os = new FileOutputStream(new File("F:\\person-template-out.xlsx"));

ExcelUtils.exportExcelByTemplate(template, user, os);
```

导出结果如下：

|A |B |C |D |E |
|----|----|----|----|----|
|姓名|张三| | | |
|年龄|25| | | |
|毕业学校|毕业时间| |工作单位|入职时间|
|实验小学|2005-07-01| |华为技术有限公司|2015-07-01|
|实验中学|2008-07-01| |厦门巨龙|2019-07-01|
|实验高中|2011-07-01| | | |	
|北京大学|2015-07-01| | | |	

- example12：使用模板导出结果集，支持定义元数据，对导出数据做字典、日期等转换

excel示例模板如下：

|姓名|性别|创建时间|
|----|----|----|
|{.name}|{.sex}|{.createTime}|

导出示例代码如下：

```java
List<Map<String, Object>> data = new ArrayList<Map<String, Object>>() {
{

    Map<String, Object> map1 = new HashMap<String, Object>();
    map1.put("name", "张三");
    map1.put("sex", "1");
    map1.put("createTime", "20200701122526");
    add(map1);

    Map<String, Object> map2 = new HashMap<String, Object>();
    map2.put("name", "李四");
    map2.put("sex", "1");
    map2.put("createTime", "20200701122528");
    add(map2);

    Map<String, Object> map3 = new HashMap<String, Object>();
    map3.put("name", "王五");
    map3.put("sex", "2");
    map3.put("createTime", "20200701122529");
    add(map3);
}
};

// 指定excel元数据，即数据进行列名映射，代码、枚举、日期翻译等处理
List<MetaData> columns = new ArrayList<MetaData>() {
{
    add(new MetaData(MetaDataType.CHAR, "name", "姓名", ""));
    add(MetaData.newCodeMetaData("sex", "性别","DM_SEX"));
    add(MetaData.newDateMetaData("createTime","创建时间","yyyy-MM-dd HH:mm:ss"));
}
};

InputStream template = ExcelUtils.readInputStream(new File("F:\\person-template.xlsx"));
FileOutputStream os = new FileOutputStream(new File("F:\\person-template-out.xlsx"));

ExcelUtils.exportExcelByTemplate(template,data,columns,os);
//同时支持列合并单元格导出
ExcelUtils.exportExcelByTemplate(template,data,columns,os,new String[] {"sex"});
```

导出结果如下：

|姓名|性别|创建时间|
|----|----|----|
|张三|男|2020-07-01 12:25:26|
|李四|男|2020-07-01 12:25:28|	
|王五|女|2020-07-01 12:25:29|

- example13：使用模板循环写入结果集，支持定义元数据，对导出数据做字典、日期等转换

excel示例模板如下：

|姓名|性别|创建时间|
|----|----|----|
|{.name}|{.sex}|{.createTime}|

导出示例代码如下：

```java
// 指定excel元数据，即数据进行列名映射，代码、枚举、日期翻译等处理
List<MetaData> columns = new ArrayList<MetaData>() {
    {
        add(new MetaData(MetaDataType.CHAR, "name", "姓名", ""));
        add(MetaData.newCodeMetaData("sex", "性别","DM_SEX"));
        add(MetaData.newDateMetaData("createTime","创建时间","yyyy-MM-dd HH:mm:ss"));
    }
};

InputStream template = ExcelUtils.readInputStream(new File("F:\\person-template.xlsx"));
FileOutputStream os = new FileOutputStream(new File("F:\\person-template-out.xlsx"));

ExcelUtils.exportExcelByTemplate(template,new ExcelWriteHandler<Map<String, Object>>() {
    @Override
    public void applyData() {
        //分批次获取数据
        PersistentFactory.getJdbcDao().queryForProcess("select * from t_person where is_deleted=?", new String[] {"0"}, new ProcessCallBack() {
            @Override
            public int getBatchSize() {
                return 1000;
            }
            @Override
            public boolean process(List<Map<String, Object>> list, long currentRowIndex) {
                //写入数据
                write(list);
                return false;
            }
        });
    }
},columns,os);

//导出时也可指定列进行单元格合并
ExcelUtils.exportExcelByTemplate(template,new ExcelWriteHandler<Map<String, Object>>() {
    @Override
    public void applyData() {
        //分批次获取数据
        PersistentFactory.getJdbcDao().queryForProcess("select * from t_person where is_deleted=?", new String[] {"0"}, new ProcessCallBack() {
            @Override
            public int getBatchSize() {
                return 1000;
            }
            @Override
            public boolean process(List<Map<String, Object>> list, long currentRowIndex) {
                //写入数据
                write(list);
                return false;
            }
        });
    }
    //按照性别列进行合并
},columns,os,new String[]{"sex"});
```

导出结果如下：

|姓名|性别|创建时间|
|----|----|----|
|张三|男|2020-07-01 12:25:26|
|李四|男|2020-07-01 12:25:28|	
|王五|女|2020-07-01 12:25:29|


## Word导出工具类


- WordUtils

```java
//加载word模板，可将编辑好的word模板文件另存为xml，然后使用freemark模板语言编写模板
InputStream template = new FileInputStream(new File("D:\\word-template.xml"));
//需要输出的文件
PrintWriter out = new PrintWriter(new File("D:\\word.doc"));

//模板中的数据
Map<String, Object> wordData = new HashMap<String, Object>();
wordData.put("name", "张三");
//解析word模板并使用freemark将模板格式化输出word文档，可直接传入response.getWriter()向客户端写入
WordUtils.exportWord(template, wordData, out);
//也可以自定义freemark工具类(具体使用参照FreemarkerUtils)处理一些复杂逻辑数据写出
WordUtils.exportWord(template, wordData, new FreemarkMethod(), out);
```
